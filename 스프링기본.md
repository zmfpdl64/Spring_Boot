 VCS코드에서 실행하는 방법
 
 gradlew파일을 이용하여 실행한다.
 ./gradlew bootRun


<h3>사용 라이브러리</h3>

엄청 많은 라이브러리를 내가 추가하지 않아도 의존성 때문에 많은 라이브러리가 내 폴더에 저장된다.

1. thymeleaf

2. spring-web
spring-boot-starter-tomcat(웹서버)
spring-webmvc: (스프링 웹 MVC)

3. spring-starter

spring-boot-starter(공통): 스프링 부트 + 스프링 코어 + 로깅

spring-boot

    -spring-core

spring-boot-starter-logging

    -logback, slf4j


4. junit-vintage-engine

내가 불러온 plugin은 4가지 밖에 안되지만 의존성 때문에 연관된 수많은 라이브러리가 자동으로 다운된다.


<h5>테스트 라이브러리</h5>

spring-boot-starter-test

    junit:테스트 프레임워크

    mockito: 목 라이브러리

    assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리

    spring-test: 스프링 통합 테스트 지원


<h5>View 환경설정</h5>

<h7>https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web</h7>

spring-boot 공식 문서

static/index.html 파일을 생성하면 Welcome page 기능을 제공한다.

<h7>thymeleaf 템플릿 엔진</h7>

https://thymeleaf.org

백엔드에서 데이터를 받아오면 프론트엔드에서 data를 사용하기 위한 템플릿 엔진이다.

사용되는 라이브러리

1. org.springframework.stereotype.Controller
//  source/template/(name).html
// 백엔드에서 return으로 String을 전달해주면 템플릿 폴더 안에 일치하는 이름을 찾아 렌더링 해준다.

2. org.springframework.ui.Model
// 데이터 셋을 전달하기 위한 {key: value}를 전달한다.
// 프론트 엔드에서는 key를 변수로 사용한다. 

3. org.springframework.web.bind.annotation.GetMapping
// 특정 url을 입력받으면 실행된다.


<h5>Build 실행</h5>

1. ./gradlew build //빌드하여 실행파일 생성 lib폴더도 이 때 생성된다.

2. cd build/lib/ 실행 폴더로 이동

3. java -jar (파일 snabshot) //실행

or

1. ./gradlew bootrun //그래드파일로 바로 실행

만약 실행하다 오류가 나는 경우

./gradlew clean build // 빌드폴더를 삭제하고 다시 설치한다.


<h5>스프링 웹 개발 기초</h5>




<li>   정적 컨텐츠</li>

<li>   MVC와 템플릿 엔진</li>

<li>   API</li>


<h5>정적 컨텐츠<h5>


<li> 스프링 부트 정적 컨텐츠 기능</li>



    HTML, JAVASCRIPT, CSS

정적 파일이란 static폴더 안에 있는 html파일을 의미한다.

정적 파일 접근 동작 순서

1. GetMapping을 돌아다니며 일치하는 url신호가 있는지 확인한다.

2. 없으면 static폴더에서 일치하는 파일이 있는지 확인한 후 일치 한다면 파일을 사용자에게 전달한다.


<h3>MVC와 템플릿 엔진</h3>

<li>MVC:Model, View, Controller</li>

Controller, Model

    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello-mvc";

 
View
 
    html xmlns:th="http://www.thymeleaf.org" lang="en"
    head
        <title>hello-mvc</title>
    head
    body
        p th:text="'hello ' + ${name}">hello! empty /p 
        <!-- 모델의 key값이 name인 value를 출력한다. 만약 text값이 존재하지 않는다면 p태그 사이의 값이 출력된다. -->
    body
    html

정적 템플릿은 바로 html을 전달해줬지만

동적 템플릿은 thymeleaf엔진을 사용하기 때문에 한번 변환한 데이터를 사용자에게 전달해준다.




<h5>API</h5>

    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello(name, 25);
        return hello;   
    }

API방식은 ResponseBody를 사용하여 객체를 전달하며 객체가 전달될 경우 Json형식으로 전달된다.

//Hello 객체를 반환해서 {key : value, key : value}를 반환한다.

과거에 html 방식과 api방식을 반환하는 방식이 충돌했는데 현재는 API방식이 채택되었다.



@ResponseBody
<li> HTTP의 BODY에 문자 내용을 직접 반환</li>
<li> viewResolver 대신에 HttpMessageConverter가 동작한다.</li>
<li> 기본 문자처리: StringHttpMessageConverter</li>
<li> 기본 객체처리: MappingJackson2HttpMessageConverter</li>
<li> byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있다</li>


참고: 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 HttpMessageConverter가 선택된다.


<h3>회원 관리 예제 - 백엔드 개발</h3>

비지니스 설계

<li> 컨트롤러: 웹 MVC의 컨트롤러 역할</li>
<li> 서비스: 핵심 비즈니스 로직 구현</li>
<li> 리포지토리: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리</li>
<li> 도메인: 비즈니스 도메인 객체, 예) 회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장하고 관리됨</li>

